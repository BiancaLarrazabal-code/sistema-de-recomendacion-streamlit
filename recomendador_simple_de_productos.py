# -*- coding: utf-8 -*-
"""Recomendador simple de productos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h5Y0mAUSqLPlp8LkDNTBvpnaUnRFcOI_

#**Recomendador simple de productos**

Este proyecto es ideal porque aplica un concepto de machine learning muy popular en una aplicaci칩n de negocio muy clara. Se puede crear un sistema de recomendaci칩n que sugiera productos o contenido a los usuarios.
"""

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt
pip install streamlit
import streamlit as st

"""##**Generaci칩n de 1,000 datos de productos**"""

# Se utiliza una semilla para asegurar que los datos sean siempre los mismos.
np.random.seed(42)

# Se generan 1,000 productos con 5 caracter칤sticas aleatorias.
# Las caracter칤sticas (features) podr칤an representar cosas como precio, tama침o, etc.
# Se crean 5 columnas de n칰meros aleatorios para simular las caracter칤sticas de los productos.
features_data = np.random.rand(1000, 5) * 100
product_ids = [f'product_{i+1}' for i in range(1000)]
products_df = pd.DataFrame(features_data, columns=['feature_1', 'feature_2', 'feature_3', 'feature_4', 'feature_5'], index=product_ids)

"""##**2. Normalizaci칩n de datos**

La normalizaci칩n asegura que las diferentes caracter칤sticas de los productos (como el precio, la calificaci칩n de estrellas, etc.) tengan el mismo peso.

La normalizaci칩n es un paso crucial para que todas las caracter칤sticas tengan el mismo peso y el sistema de recomendaci칩n no se incline hacia una sola.
"""

from sklearn.preprocessing import MinMaxScaler

# Se crea un objeto para escalar los datos.
scaler = MinMaxScaler()

# Se normalizan los datos para que todos los valores est칠n entre 0 y 1.
products_normalized = scaler.fit_transform(products_df)

# Se convierte de nuevo a un DataFrame con los mismos 칤ndices y columnas.
products_normalized_df = pd.DataFrame(products_normalized, columns=products_df.columns, index=products_df.index)

# Ahora, la matriz de similitud se calcula con los datos normalizados.
# Se reemplaza la siguiente l칤nea:
# similarity_matrix = cosine_similarity(products_df)
# Por esta:
similarity_matrix = cosine_similarity(products_normalized_df)

"""##**3. L칩gica del sistema: C치lculo de similitud**

"""

# El "n칰cleo" del recomendador
# Se calcula la matriz de similitud usando la similitud del coseno.
# El resultado es una matriz donde cada valor indica la similitud entre dos productos.
similarity_matrix = cosine_similarity(products_df)

# Se convierte la matriz de similitud en un DataFrame de pandas para facilitar el trabajo.
similarity_df = pd.DataFrame(similarity_matrix, index=products_df.index, columns=products_df.index)

"""##**4. Funci칩n de recomendaci칩n**"""

def get_recommendations(product_id, similarity_df, num_recommendations=5):
    """
    Funci칩n que recomienda productos similares a un producto dado.

    Args:
        product_id (str): El ID del producto para el que se buscan recomendaciones.
        similarity_df (pd.DataFrame): La matriz de similitud de productos.
        num_recommendations (int): El n칰mero de recomendaciones a devolver.

    Returns:
        list: Una lista de los IDs de los productos recomendados.
    """
    if product_id not in similarity_df.index:
        print(f"Error: El producto '{product_id}' no se encuentra en el cat치logo.")
        return []

    # Se obtienen las puntuaciones de similitud para el producto de referencia.
    similarity_scores = similarity_df[product_id]

    # Se ordenan las puntuaciones en orden descendente.
    # Se excluye el producto en s칤 mismo (su similitud es 1).
    sorted_scores = similarity_scores.sort_values(ascending=False)

    # Se obtienen los IDs de los productos m치s similares.
    top_recommendations = sorted_scores.index[1:num_recommendations+1]

    return top_recommendations.tolist()

# --- Ejemplo de uso con una muestra grande ---
# Se elige un producto al azar de la muestra.
target_product = np.random.choice(products_df.index)

# Se llama a la funci칩n para obtener las recomendaciones.
recommended_products = get_recommendations(target_product, similarity_df)

# Se imprimen los resultados para el usuario.
print(f"Producto de referencia: {target_product}")
print("---")
print("Productos recomendados:")
for product in recommended_products:
    print(f"- {product}")

"""##**5. Imprimir las caracter칤sticas de los productos para ver la similitud.**


"""

print("\nCaracter칤sticas del producto de referencia:")
print(products_df.loc[[target_product]])
print("\nCaracter칤sticas de los productos recomendados:")
print(products_df.loc[recommended_products])

"""##**6. Uso del sistema y visualizaci칩n de resultados**"""

# Se elige un producto al azar de la muestra. Esto simula que un usuario ha seleccionado un producto.
target_product = np.random.choice(products_df.index)

# Se llama a la funci칩n para obtener las recomendaciones.
recommended_products = get_recommendations(target_product, similarity_df)

# Se imprimen los resultados para el usuario.
print(f"Producto de referencia: {target_product}")
print("---")
print("Productos recomendados:")
for product in recommended_products:
    print(f"- {product}")

"""##**7. Visualizaci칩n de los Resultados**


"""

import matplotlib.pyplot as plt

# Se obtienen las puntuaciones de similitud para los productos recomendados.
# Se usa .loc[] para asegurar que el orden de los productos en el gr치fico coincida
# con el orden de las recomendaciones.
recommended_scores = similarity_df.loc[target_product, recommended_products]

# Se crea un gr치fico de barras para visualizar la similitud.
plt.figure(figsize=(10, 6))
# Se usa plt.bar() directamente para tener m치s control sobre la visualizaci칩n.
plt.bar(x=recommended_scores.index, height=recommended_scores.values, color='skyblue')
plt.title(f'Similitud de productos recomendados para {target_product}')
plt.xlabel('ID del producto')
plt.ylabel('Puntuaci칩n de similitud')
plt.xticks(rotation=45)
plt.show()
plt.show()

"""##**8. Guardar los Resultados en un Archivo**

"""

# Se crea un DataFrame con los productos recomendados y su puntuaci칩n de similitud.
results_df = pd.DataFrame({
    'product_id': recommended_products,
    'similitud': recommended_scores.values
})

# Se guarda el DataFrame en un archivo CSV.
results_df.to_csv('recomendaciones_finales.csv', index=False)
print("\nLos resultados han sido guardados en 'recomendaciones_finales.csv'")

"""##**9. Interfaz de Usuario Simple**"""

# Se a침ade un bucle para que el usuario pueda seguir pidiendo recomendaciones.
while True:
    user_input = input("\nIngresa el ID de un producto (ej: product_123) o 'salir': ")
    if user_input.lower() == 'salir':
        break

    # Se obtienen las recomendaciones para el producto ingresado por el usuario.
    user_recommendations = get_recommendations(user_input, similarity_df)

    if user_recommendations:
        print(f"Productos recomendados para {user_input}:")
        for product in user_recommendations:
            print(f"- {product}")

"""##**10. Interfaz de usuario con Streamlit**"""

# Se crea el t칤tulo de la aplicaci칩n.
st.title("Sistema de Recomendaci칩n de Productos")

# Se crea un selector para que el usuario elija un producto.
product_to_recommend = st.selectbox(
    'Selecciona un producto para ver las recomendaciones:',
    options=product_ids
)

# Se crea un bot칩n para activar las recomendaciones.
if st.button('Obtener Recomendaciones'):
    # Se obtienen las recomendaciones y se muestran los resultados.
    recommended_products = get_recommendations(product_to_recommend, similarity_df)

    if recommended_products:
        st.subheader("Productos Recomendados")
        for product in recommended_products:
            st.write(f"- {product}")

        # --- Visualizaci칩n de los Resultados ---
        # Se obtienen las puntuaciones de similitud para los productos recomendados.
        recommended_scores = similarity_df.loc[product_to_recommend, recommended_products]

        # Se crea un gr치fico de barras para visualizar la similitud.
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.bar(x=recommended_scores.index, height=recommended_scores.values, color='skyblue')
        ax.set_title(f'Similitud de productos recomendados para {product_to_recommend}')
        ax.set_xlabel('ID del producto')
        ax.set_ylabel('Puntuaci칩n de similitud')
        ax.tick_params(axis='x', rotation=45)
        st.pyplot(fig)

        # --- Guardar los Resultados en un Archivo ---
        # Se crea un DataFrame con los productos recomendados y su puntuaci칩n de similitud.
        results_df = pd.DataFrame({
            'product_id': recommended_products,
            'similitud': recommended_scores.values
        })

        # Se guarda el DataFrame en un archivo CSV.
        results_df.to_csv('recomendaciones_finales.csv', index=False)
        st.success("Los resultados han sido guardados en 'recomendaciones_finales.csv'")

"""##**11. Archivo app.py**"""

# Commented out IPython magic to ensure Python compatibility.
# # Esta celda escribe el archivo 'app.py' en el entorno de Colab.
# # Es el 칰ltimo paso en el cuaderno antes de subirlo a GitHub.
# # NOTA: No se copia esta l칤nea (%%writefile) en el archivo de GitHub.
# 
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import seaborn as sns
# import matplotlib.pyplot as plt
# import numpy as np
# 
# # T칤tulo de la aplicaci칩n
# st.title('Dashboard de Marketing Digital 游늳')
# st.write('Analizando m칠tricas clave para la optimizaci칩n de la estrategia.')
# 
# # Carga de los datos (simulada)
# df = pd.read_csv('fake_data.csv')
# df['date'] = pd.to_datetime(df['date'])
# tipos_de_contenido = ['Video', 'Imagen', 'Carrusel']
# df['content_type'] = np.random.choice(tipos_de_contenido, size=len(df), p=[0.4, 0.4, 0.2])
# df['day_of_week'] = df['date'].dt.day_name()
# df['engagement_rate (%)'] = (df['likes'] + df['comments'] + df['shares']) / df['views'] * 100
# 
# # Gr치fico 1: Evoluci칩n de Seguidores
# st.subheader('1. Evoluci칩n de Seguidores')
# fig1, ax1 = plt.subplots(figsize=(10, 6))
# sns.lineplot(x='date', y='followers', data=df)
# plt.title('Evoluci칩n del N칰mero de Seguidores a lo largo del Tiempo')
# st.pyplot(fig1)
# 
# # Gr치fico 2: Distribuci칩n de M칠tricas
# st.subheader('2. Distribuci칩n de M칠tricas')
# fig2, ax2 = plt.subplots(figsize=(15, 8))
# plt.subplot(2, 2, 1)
# sns.histplot(df['likes'], kde=True)
# plt.title('Distribuci칩n de Likes')
# plt.subplot(2, 2, 2)
# sns.histplot(df['comments'], kde=True)
# plt.title('Distribuci칩n de Comentarios')
# plt.subplot(2, 2, 3)
# sns.histplot(df['shares'], kde=True)
# plt.title('Distribuci칩n de Compartidos')
# plt.tight_layout()
# st.pyplot(fig2)
# 
# # Gr치fico 3: Relaci칩n entre Vistas y Likes
# st.subheader('3. Relaci칩n entre Vistas y Likes')
# fig3, ax3 = plt.subplots(figsize=(10, 6))
# sns.scatterplot(x='views', y='likes', data=df)
# plt.title('Relaci칩n entre Vistas y Likes')
# st.pyplot(fig3)
# 
# # Gr치fico 4: Comparaci칩n de M칠tricas
# st.subheader('4. Comparaci칩n de M칠tricas')
# fig4, ax4 = plt.subplots(figsize=(12, 6))
# metricas_df = df[['likes', 'comments', 'shares', 'views', 'impressions', 'reach']]
# metricas_df.sum().plot(kind='bar', color=sns.color_palette('viridis'))
# plt.title('Comparaci칩n de M칠tricas Totales')
# plt.ylabel('Cantidad')
# plt.xticks(rotation=45)
# st.pyplot(fig4)
# 
# # Gr치fico 5: Top 10 Publicaciones
# st.subheader('5. Top 10 Publicaciones')
# top_posts = df.sort_values(by='likes', ascending=False).head(10)
# fig5, ax5 = plt.subplots(figsize=(12, 6))
# sns.barplot(x='likes', y='date', data=top_posts, palette='magma')
# plt.title('Top 10 Publicaciones por Likes')
# st.pyplot(fig5)
# 
# 
# # Gr치fico 6: Rendimiento del Engagement por Tipo de Contenido
# st.subheader('6. Rendimiento del Engagement por Tipo de Contenido')
# fig6, ax6 = plt.subplots(figsize=(10, 6))
# sns.boxplot(x='content_type', y='engagement_rate (%)', data=df, palette='pastel')
# plt.title('Rendimiento del Engagement por Tipo de Contenido')
# plt.xlabel('Tipo de Contenido')
# plt.ylabel('Tasa de Engagement (%)')
# st.pyplot(fig6)
# 
# # Gr치fico 7: Engagement Promedio por D칤a de la Semana
# st.subheader('7. Engagement Promedio por D칤a de la Semana')
# dias_ordenados = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
# fig7, ax7 = plt.subplots(figsize=(12, 6))
# sns.barplot(
#   x='day_of_week',
#   y='engagement_rate (%)',
#   data=df,
#   order=dias_ordenados,
#   palette='coolwarm',
#   estimator=np.mean,
#   errorbar=None
# )
# plt.title('Engagement Promedio por D칤a de la Semana')
# plt.xlabel('D칤a de la Semana')
# plt.ylabel('Tasa de Engagement Promedio (%)')
# plt.xticks(rotation=45)
# st.pyplot(fig7)
# 
# # Gr치fico 8: Matriz de Correlaci칩n General
# st.subheader('8. Matriz de Correlaci칩n General')
# df_numerico = df.select_dtypes(include=['number'])
# correlation_matrix = df_numerico.corr()
# fig8, ax8 = plt.subplots(figsize=(12, 8))
# sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
# plt.title('Mapa de Calor de Correlaci칩n entre M칠tricas')
# st.pyplot(fig8)
# 
# # Secci칩n de conclusiones
# st.subheader('Conclusiones')
# st.write('---')
# st.write('Este dashboard es un ejemplo de c칩mo transformar un an치lisis t칠cnico en una herramienta de negocio funcional. La metodolog칤a utilizada demuestra mi capacidad para generar **insights accionables** que impulsan el crecimiento empresarial.')
